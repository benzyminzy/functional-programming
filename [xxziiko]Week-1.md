# Chapter 1.

- 함수형 프로그래밍에 대한 정의, 정의의 문제점, 책의 방향 소개
<br/>
<br/>

## 1. 함수형 프로그래밍 정의

1. 수학 함수를 사용하고 부수 효과(side effect)를 피하는 것이 특징인 프로그래밍 패러다임
2. 부수 효과 없이 순수 함수만 사용하는 프로그래밍 스타일

- `부수 효과`
    - 함수가 리턴 값 이외에 하는 모든 일(ex. 메일 보내기, 전역 상태 수정하기)
    - 함수를 부를 때 마다 발생하기 때문에 문제가 될 수 있음
    - 대부분의 함수형 프로그래머는 불필요한 부수 효과를 지양
- `순수 함수`
    - 인자에만 의존하고 부수 효과가 없는 함수

<br/>
<br/>

## 2. 실용적인 측면에서 함수형 프로그래밍 정의의 문제점

1. 부수효과는 필요하다.
    - 수학적인 정의에서는 부수 효과를 피해야 하지만, 부수 효과는 소프트웨어를 실행하는 이유이다.
2. 함수형 프로그래밍은 부수 효과를 잘 다룰 수 있다.
    - 함수형 프로그래밍에서는 문제의 소지를 인지하고 있기 때문에 부수 효과를 잘 다루기 위한 도구나 기술이 많이 존재한다.
3. 함수형 프로그래밍은 실용적이다. 
    - 정의에서는 함수형 프로그래밍이 수학적이라 실제 개발에서 사용하지 않는 것 처럼 느껴지지만 사실은 잘 만들어진 소프트웨어들이 많다.
    
<br/>
<br/>

## 3. 함수형 프로그래밍은 코드를 세 가지로 분류

### 액션

- `액션`은 **실행 시점**이나 **횟수** 또는 둘 다에 의존
    - 실행 시점? 메일을 오늘 보내는 것과 다음 주에 보내는 것
    - 실행 횟수? 같은 메일을 한 번 보내는 것과 10 번 보내는 것

- `액션`과 관련된 함수형 사고
    - 시간이 지남에 따라 안전하게 상태를 바꿀 수 있는 방법
    - 순서를 보장하는 방법
    - 액션이 정확히 한 번만 실행되게 보장하는 방법
<br/>
<br/>

### 계산

- `계산`은 입력 값으로 출력 값을 만드는 것
- 같은 입력값을 가지고 계산하면 항상 같은 결괏값이 나온다.
- 테스트 하기 쉽고 시간과 횟수에 의존하지 않음

- `계산`과 관련된 함수형 사고
    - 정확성을 위한 정적 분석
    - 소프트웨어에서 쓸 수 있는 수학적 지식
    - 테스트 전략
<br/>
<br/>

### 데이터

- `데이터`는 이벤트에 대해 기록한 사실
- 알아보기 쉬운 속성으로 되어있고 실행하지 않아도 데이터 자체로 의미를 가짐
- 같은 데이터를 여러 형태로 해석할 수 있다.
    
    (ex. 같은 영수증 데이터를 가지고 **관리자**는 인기있는 메뉴를 찾는 용도로 사용, **고객**은 외식비 지출 내역을 확인하기 위해 사용)
    
- `데이터`와 관련된 함수형 사고
    - 효율적으로 접근하기 위해 데이터를 구성하는 방법
    - 데이터를 보관하기 위한 기술
    - 데이터를 이용해 중요한 것을 발견하는 원칙
    
<br/>
<br/>

# Chapter 2.

- 두 가지 함수형 사고의 기술(책 전체 내용에 대한 간단한 워밍업 예시)
    - 액션과 계산, 데이터 → 계층형 설계
    - 일급 추상 → 타임라인 다이어그램, 일급 함수
<br/>
<br/>
<br/>

## 1. 변경 가능성에 따라 코드 나누기(PART 1)

<br/>
<br/>

### 계층화 설계 맛보기

- 각 계층은 그 아래에 있는 계층을 기반으로 만들어진다.
- 따라서 각 계층에 있는 코드는 더 안정적인 기반 위에 작성할 수 있다.
- 이러한 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있다.
- 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀수 있지만 아래로 갈수록 의존성이 높아지며 자주 바뀌지 않는다.
- 이러한 아키텍처 패턴은 **계층**을 만들기 때문에 `계층형 설계(stratified design)` 라고 부른다.
- `계층형 설계`는 일반적으로 **비즈니츠 규칙**, **도메인 규칙**, **기술 스택 계층**으로 나눈다.
- `계층형 설계`로 만든 코드는 **테스트**, **재사용**, **유지보수**가 쉽다.
<br/>
<br/>

## 2. 분산 시스템을 타임라인으로 시각화하기(PART 2)

<br/>
<br/>

### 토니의 치즈피자 만들기

토니의 로봇 분산시스템 타임라인 다이어그램

- 여러 대의 로봇이 함께 일하는 것은 **분산 시스템**을 의미한다.
- 분산 시스템에서 **독립된 액션**의 **실행 순서**는 보장되지 않는다.
- 타임라인 다이어그램을 그리는 것은 분산 시스템의 타임라인을 파악하는 것에 도움이 된다.
- 순차적인 프로그램을 분산 시스템으로 동작하게 하려면 (시간에 의존적인)**액션에 집중**해야 한다.
    - 타임라인은 서로 **실행 순서**를 맞춰야 한다.
    - 액션이 실행되는 시간은 중요하지 않다.
    - 타임라인은 항상 옳바른 결과를 보장해야 한다.
<br/>
<br/>

### 개선(타임라인 컷팅 기술)


타임라인 커팅 기술을 사용한 토니의 로봇 분산시스템 타임라인 다이어그램

1. 타임라인 커팅으로 서로 다른 작업들을 쉽게 이해할 수 있다.
    - 타임라인에 컷을 그려 동시에 할 수 있는 재료 준비와 순서대로 해야하는 일을 분리
    - 더 짧아진 타임라인을 실행 순서에 상관 없이 이해할 수 있다.
2. 타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다.
3. 타임라인 다이어그램은 유연하다.
    - 시각화 된 타임라인을 보고 쉽게 코드를 옮길 수 있다.
    - 타임라인 다이어그램으로 동시에 진행되는 작업을 쉽게 모델링 할 수 있다.
<br/>
<br/>

### PART1

# Chapter 3.

- 액션과 계산, 데이터의 차이에 대한 내용
<br/>
<br/>
<br/>

## 1. 액션과 계산, 데이터

아래의 단계별로 `액션`과 `계산`, `데이터`를 구분 하는 기술을 적용할 수 있다.

1. 문제에 대해 생각할 때
    - 코딩을 시작하기 전에도 문제를 `액션`과 `계산`, `데이터`로 나누어 생각해 볼 수 있다.
    - 문제를 액션과 계산, 데이터로 나누면 코드를 작성할 때 특별히 주의해야 할 부분(`액션`)과 `데이터`로 처리해야 할 부분, 결정을 내려야 하는 부분(`계산`)을 명확하게 알 수 있다.
2. 코딩 할 때
    - 함수형 프로그래머는 코딩할 때 최대한 `액션`에서 `계산`을 빼내려고 한다.
    - `계산`에서는 `데이터`를 분리할 수 있는지 생각한다.
    - `액션`이 `계산`이 될 수 있는지, `계산`은 `데이터`가 될 수 있는지 고민한다.
3. 코드를 읽을 때
    - 코드를 읽을 때 `액션`과 `계산`, `데이터` 중 어떤 것에 속하는지 살펴봐야 한다.
    - `액션`은 **시간에 의존**하기 때문에 더 조심해야 한다.
<br/>
<br/>

### **장보기 과정을 예시로 액션과 계산, 데이터 구분해보기**

**냉장고 확인하기**

- 냉장고 확인하는 일은 **확인하는 시점**이 중요하기 때문에 `액션`이다.
- 냉장고가 가지고 있는 제품은 `데이터`이다.
- 냉장고가 가지고 있는 데이터를 현재 재고(current inventory)라고 명명


**운전해서 상점으로 가기**

- 운전해서 상점으로 가는 것은 명확한 `액션`이다.
- 상점 위치나 가는 경로는 `데이터` 라고 할 수 있다.

**필요한 것 구입하기**

- 구입하는 일도 `액션`이다.
- 구입하는 과정은 몇 단계로 나눌 수 있다.
- 필요한 것을 구입하려면 무엇이 필요한지 알아야 한다. → 필요하지만 없는 제품의 목록을 만든다.
    - 필요한 재고 - 현재 재고 = 장보기 목록
    - 현재 재고는 ‘냉장고 확인하기’ 단계에서 만든 `데이터`

<br/>
<br/>

## 2. 장보기 과정에서 배운 것

1. `액션`과 `계산`, `데이터`는 어디에나 적용할 수 있다.
2. `액션` 안에는 `계산`과 `데이터`, 또 다른 `액션`이 숨어있을 수 있다.
    - 단순해 보이는 `액션`일지라도 또 다른 `액션`이나 `계산`,`데이터`로 나눌 수 있다.
    - 함수형 프로그래밍에서는 액션을 더 작은 `액션`과 `계산`, `데이터`로 나누고 그것을 언제 멈춰야 할 지 아는 것이 중요하다.
3. `계산`은 더 작은 `계산`과 `데이터`로 나누고 연결할 수 있다.
    - ‘필요한 것 구입하기’ 단계에서 계산에 필요한 `데이터`를 찾는 과정이 그 예시다.
    - `계산`을 더 작은 계산으로 나누는 것이 더 좋을 때도 있다.
    - `계산`을 나누면 첫 번째 `계산`의 결과 `데이터`가 두 번째 `계산`의 입력이 된다.
4. `데이터`는 `데이터`만 조합할 수 있다.
    - `데이터` 찾는일을 먼저 해야 한다.
    - `데이터`를 찾았다면 동작에 대해 많은 것을 알 수 있다.
5. `계산`은 때로 ‘우리 머릿속에서’ 일어난다.
    - 계산 단계가 있지만 잘 보이지 않는 이유는 `계산`이 사고 과정에 녹아있기 때문이다.
    - 이 사실을 인지한다면 `계산`을 더 쉽게 찾을 수 있다.
    - 어떤 단계에서 무엇인가 결정 해야 할 것이 있는지 스스로 물어본다. → 결정과 계획은 `계산`이 될 가능성이 높다.
<br/>
<br/>

## 3. 쿠폰 보내는 과정 그려보기

**데이터 베이스에서 구독자를 가져오기**

- 이 단계는 `액션`이다.
- 구독자는 계속 바뀌기 때문에 이 단계는 **실행** **시점에 의존**한다.
- 구독자를 데이터베이스에서 가져오면 사용자 목록을 얻을 수 있고 이 것은 `데이터`이다.


**데이터베이스에서 쿠폰 목록 가져오기**

- 이 단계도 `액션`이다.
- 쿠폰 데이터베이스도 계속 바뀌기 때문에 이 단계도 **실행 시점에 의존**한다.
- 가져온 쿠폰 목록은 `데이터`이다.
- 쿠폰 목록 데이터는 DB 쿼리 이벤트에 대한 사실이다.

**이메일 만드는 부분을 자세히 살펴보기** 


- 이메일 목록을 계획하는 `계산`은 구독자 목록 `데이터`와 쿠폰 목록 `데이터`를 받고, 계산한 결과는 **이메일 목록**이다.
    
    
    <aside>
    ‼️ 함수형 프로그래머는 일반적으로 가능하면 `액션`을 쓰지 않으려고 한다. 
    → `계산`으로 바꿀 수 있는 `액션`이 있다면 바꾸는 것이 좋다.
    
    </aside>
    

- `계산`을 사용하려고 하는 이유는 테스트 하기 쉽기 때문이다.
- 이메일을 실제로 보내고 결과를 주는 시스템은 테스트하기 어렵지만 결과가 이메일 목록 데이터 시스템은 테스트 하기 쉽다. (계산은 외부에 영향을 주지 않기 때문)

**어떤 구독자가 어떤 이메일을 받을지 결정하는 계산하기**


- 이메일을 만드는 계산에서 한번 더 `계산`과 `데이터`를 나누는 과정
- 구독자의 목록을 가지고 위 과정에 반복해서 적용하면 전체 구독자에 대한 이메일 목록을 얻을 수 있다.
- 현재 시점에서 `계산`을 더 나눌 수 있고, `계산`을 나누면 구현하기 쉬워지지만 **충분히 구현하기 쉽다고 생각하는 시점에서 멈춰야 한다.**

- 생각한 `계산`을 구현


- 어떤 구독자가 어떤 등급의 쿠폰을 받을지 결정하는 함수
- 이 함수는 명확하고 테스트하기 쉬우며 재사용할 수 있다.

- 전체 쿠폰 목록에서 주어진 등급의 쿠폰 목록만 선택하는 부분을 구현

**데이터베이스에서 가져온 쿠폰 데이터**

- 구독자 데이터처럼 쿠폰 데이터도 자바스크립트 객체로 표현할 수 있다.
- 테이블은 같은 모양의 자바스크립트 객체를 담고 있는 배열로 볼 수 있다.

**특정 등급의 쿠폰 목록을 선택하는 계산은 함수이다.**

- 입력값은 전체 쿠폰 목록과 선택할 등급이다. 출력값은 선택한 등급을 가진 쿠폰 목록이다.


**구독자가 받을 이메일을 계획하는 계산**


- 구독자에 대한 이메일을 만드는 함수이기 때문에 구독자를 인자로 받아야 한다.
- 이메일에는 쿠폰 정보가 있어야 하기 때문에 쿠폰 목록도 입력값으로 받아야 한다.
- 구독자가 받아야 할 쿠폰이 good 쿠폰 목록일지 best 쿠폰일지 미리 알 수 없기 때문에 두 목록 모두 입력 값으로 받아야 한다.
- 결괏값은 이메일 데이터이다.


- 이 함수는 외부에 어떤 영향도 주지 않고 입력갑에 따라 이메일을 결정하고 리턴하는 계산함수이다.
<br/>
<br/>

## 4. 이미 있는 코드에 함수형 사고 적용하기

- 이미 존재하는 코드에 함수형 사고를 적용할 수도 있다.
- 코드를 읽을 때 `액션`과 `계산`, `데이터` 관점으로 읽는다.


- 위의 함수에서 `액션`은 하나만 있을까? → No
- 위의 코드는 함수형 코드라고 하기 어렵다. → 함수형 사고를 적용하지 않은 코드이다.
- 위의 함수는 모두 `액션`이다.
- `액션`을 부르는 함수가 있다면 그 함수도 `액션`이 된다. → `액션` 하나가 코드 전체가 될 수 있다.
- 따라서 `액션`을 신중하게 사용해야 한다.

**액션을 잘 사용할수 있는 방법**

1. 가능한 `액션`을 적게 사용한다. 
2. `액션`을 가능한 작게 만든다. `액션`과 관련 없는 코드는 모두 제거한다.
3. `액션`이 외부 세계와 상호작용 하는 것을 제한한다.
4. `액션`이 호출 시점에 의존 하는 것을 제한한다.
