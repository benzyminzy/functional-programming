# Chapter 8.

- 소프트웨어 설계에 대한 실용적인 정의
- 계층형 설계 이해
- 클린코드 함수 추출

<br/>
<br/>
<br/>

### 소프트웨어 설계

- 코드를 만들고 테스트와 유지보수 하기 쉬운 프로그래밍 방법을 선택하기 위해 미적 감각을 사용하는 것

<br/>
<br/>

## 계층형 설계?

- 소프트웨어를 계층으로 구성하는 기술
- 계층을 구분하는 것은 명확하지 않고 복잡하게 섞여 있지만 좋은 설계를 위한 감각을 개발하면 ‘가장 좋은 설계’에 대한 공식을 찾을 수 있음

<br/>
<br/>

## 계층형 설계 패턴

- 패턴1: 직접 구현
    - 계층형 설계 구조를 만드는 것에 도움이 됨
    - 직접 구현된 함수를 읽을 때, 함수 시그니처가 나타내고 있는 문제를 함수 본문에서 적절하게 구체화 해야 한다.
- 패턴2: 추상화 벽
    - 호출 그래프에 어떤 계층은 중요한 세부 구현을 감추고 인터페이스를 제공.
    - 인터페이스를 사용하여 코드를 만들면 높은 차원으로 생각할 수 있고, 그 단계의 추상화만 생각하면 되기 때문에 두뇌 용량의 한계를 극복할 수 있음.
- 패턴3: 작은 인터페이스
    - 시스템이 클수록 비즈니스 개념을 나타내는 인터페이스는 작고 강력한 동작으로 구성하는 것이 좋다.
    - 직간접적으로 최소한의 인터페이스를 유지하면서 정의해야 한다.
- 패턴4: 편리한 계층
    - 계층형 설계 패턴과 실천 방법은 개발자의 요구와 함께 비즈니스 문제를 잘 풀 수 있어야 한다.
    - 고품질의 소프트웨어를 개발하기에 알맞은 계층에 시간을 투자해야함.
    
<br/>
<br/>

## 패턴1: 직접구현

### 호출 그래프를 만들어 함수 호출을 시각화하기

- 화살표의 길이에 따라 추상화 수준이 다르다
- 직접 만든 함수와 배열 인덱스 참조기능과 같은 언어에서 제공하는 기능은 추상화 수준이 다르다. → 반복문과 배열 인덱스를 참조하는 기능은 더 낮은 추상화 단계
- 직접 구현 패턴을 사용하면 **비슷한 추상화 계층에 있는 함수를 호출**한다.
- 함수 이름은 함수가 어느 곳에 위치할 지 결정하기 위한 정보로 쓸 수 있다.

### 같은 계층에 있는 함수는 같은 목적을 가져야 한다.

- 각 계층은 추상화 수준이 다르다.
- 어떤 계층에 있는 함수를 읽거나 수정할 때 낮은 계층의 내용은 신경쓰지 않아도 된다.
- 다이어그램은 함수를 높은 차원에서 볼 수 있는 좋은 도구

<br/>
<br/>

## 직접 구현이 어떻게 계층형 설계에 도움이 ? → 3단계 줌 레벨

- 계층형 설계에서 문제를 세 가지 영역에서 찾을 수 있음
    1. 계층 사이의 상호 관계
    2. 특정 계층의 구현
    3. 특정 함수의 구현
    
    → 문제를 찾기 위해 알맞은 줌 레벨을 사용하여 하나의 영역에서 살펴볼 수 있음
    
    1. 전역 줌 레벨
        - 그래프 전체 중 필요한 부분을 살펴볼 수 있음
        - 기본 줌 레벨
        - 계층 사이의 상호 관계를 포함하여 모든 문제 영역을 살펴볼 수 있음
    
    1. 계층 줌 레벨
        - 한 계층과 연결된 바로 아래 계층을 볼 수 있는 줌 레벨
        - 계층이 **어떻게 구현되어 있는지** 알 수 있음
    
    1. 함수 줌 레벨
        - 함수 하나와 바로 아래 연결된 함수들을 볼 수 있음
        - 함수 줌 레벨로 함수 구현의 문제를 찾을 수 있음
        - 그래프를 살펴보면 서로 다른 계층의 동작을 사용 → 직접 구현 패턴에 맞지 않음
        - 해결하기 위해서는 반복문을 빼내 새로운 함수를 만들어 중간에 둠으로써 화살표 길이를 일정하게 만든다.
        
    
<br/>
<br/>

## 직접 구현 패턴 리뷰

- 한단계의 구체화 수준에 관한 문제만 해결한다.  → 코드를 읽기 위해 알아야 하는 구체화 단계의 범위를 줄일 수 있다.
- 특정 구체화 단계에 집중할 수 있게 도와준다.
- 호출 그래프는 구체화 단계에 대한 풍부한 단서를 보여준다.
- 함수를 추출하면 더 일반적인 함수로 만들 수 있다.
    - 함수에 직접 구현 패턴을 적용할 때, 함수가 더 구체적인 내용을 다루지 않도록 일반적인 함수로 빼낸다.
    - 일반적인 함수는 보통 구체적인 내용 하나만 다루기 때문에 테스트하기 쉽다.
- 일반적인 함수가 많을수록 재사용하기 좋다.
    - ‘중복 코드’를 찾기 위해 함수를 빼내는 것과는 다른 것이다.
- 복잡성을 감추지 않는다.
    - 계층형 설계에서는 모든 계층은 바로 아래층 계층에 의존적임. → 이 것을 지켜서 직접 구현 패턴을 적용하다 보면 복잡성이 드러남.

<br/>
<br/>

## 요점 정리

- 계층형 설계는 코드를 추상화 계층으로 구성 → 각 계층은 다른 계층의 구체적인 내용을 몰라도 됨
- 문제 해결을 위한 함수를 구현할 때, 어떤 구체화 단계로 쓸 지 결정하는 것이 중요하다
- 함수 이름, 본문, 호출 그래프 등을 통해 함수가 어떤 계층에 속할지 알 수 있다.
- 함수 이름은 그 함수의 의도를 알려준다. 비슷한 목적의 이름을 가진 함수를 묶을 수 있다.
- 함수 본문은 중요한 세부 사항을 알려준다. → 어떤 계층 구조에 있어야 하는지 알려줌
- 호출 그래프로 구현이 직접적이지 않다는 것을 알 수 있다. → 호출그래프의 화살표가 다양한 길이를 가진다면 직접 구현되어 있지 않다는 뜻

<br/>
<br/>

# Chapter 9.

- 코드 모듈화를 위해 추상화 벽을 만드는 법
- 좋은 인터페이스란? 어떻게 찾는지?
- 설계의 마무리 시점
- 계층형 설계가 유지보수와 테스트, 재사용에 도움이 되는 이유

<br/>
<br/>
<br/>


## 패턴2: 추상화 벽

- 세부 구현을 감춘 함수로 이루어진 계층
- 추상화 벽에 있는 함수를 사용할 때는 구현을 전혀 몰라도 함수를 사용할 수 있음

<br/>
<br/>

## 세부적인 것을 감추는 것은 대칭적이다

- 추상화 벽을 사용한 함수는 구현을 신경쓰지 않아도 된다. → 독립적이다 → 대칭적이다
- 라이브러리나 API 를 예로 들어 생각하면 이해하기 쉽다.
    - api나 라이브러리의 세부 코드를 몰라도 사용할 수 있는 것 처럼..

<br/>
<br/>


## 데이터 구조를 바꾸는 것

- 배열에서 객체로 바꾸는 것은 첫번째 패턴인 직접 **구현 패턴**에 가깝다.
- 배열보다 객체가 어떤 위치에 추가하거나 삭제하기 용이하다 → 효율적
- **추상화 벽**은 **‘어떤것을 신경 쓰지 않아도 되지?’** 라는 말을 거창하게 표현한 개념

<br/>
<br/>

## 추상화 벽은 언제 사용하면 좋을까?

1. 쉽게 구현을 바꾸기 위해
    - 추상화 벽을 사용하면 최선의 구현을 확신할 수 없는 작업에 유용
    - 추상화 벽을 사용하면 구현을 간접적으로 사용할 수 있기 때문에 나중에 수정하기 용이함
    - 하지만 만약을 대비하여 코드를 만드는 경우가 종종 생기기 때문에 주의해야 한다
2. 코드를 읽고 쓰기 쉽게 만들기 위해 
3. 팀 간에 조율을 줄이기 위해
4. 주어진 문제에 집중하기 위해

<br/>
<br/>

## 패턴2 리뷰: 추상화 벽

- 추상화 벽은 추상화 벽 아래에 있는 코드와 위에 있는 코드의 의존성을 없앤다.
- 추상화 벽 위에 있는 코드는 데이터 구조와 같은 구체적인 내용을 신경쓰지 않아도 됨.
- 추상화 벽 아래에 있는 코드는 높은 수준의 계층에서 함수가 어떻게 사용되었는지 몰라도 됨
- 추상화 벽으로 추상화를 강력하고 명시적으로 만들 수 있음

<br/>
<br/>

## 패턴 3: 작은 인터페이스

- 새로운 코드를 추가할 위치에 관련
- 인터페이스를 최소화하면 하위 계층에 불필요한 기능이 쓸데 없이 커지는 것을 막을 수 있다.
- 새로운 기능을 추가할 때 상위 계층에 만드는 것이 작은 인터페이스 패턴이라고 할 수 있음
- 상위 계층에 어떤 함수를 만들 때 가능한 현재 계층에 있는 함수로 구현하는 것이 작은 인터페이스를 실천하는 방법

<br/>
<br/>

## 패턴4: 편리한 계층

- 스스로 생각했을때 작업한 코드가 편리하다고 느낀다면 설계를 멈춰도 됨.
- 코드가 지저분해진다고 느껴질 때 다시 앞의 패턴을 적용
- 어떤코드도 이상적인 모습에 도달할 수 없음

<br/>
<br/>


## 그래프로 알 수 있는 코드에 대한 정보

- 호출 그래프의 구조는 세가지 중요한 `비기능적 요구사항`을 잘 보여준다.
- `기능적 요구사항`은 소프트웨어가 정확하게 해야 하는 일을 말한다.
- `비기능적 요구사항` 은 **테스트성**, **재사용성**, **유지보수성**에 대한 요구사항들을 말한다.
- `비기능적 요구사항` 은 소프트웨어를 설계하는 중요한 이유

<br/>
<br/>

## 그래프의 가장 위에 있는 코드가 고치기 쉽다

- 가장 높은 계층에 있는 코드는 호출하는 곳이 없기 때문에 다른 코드에 영향을 주지 않고 바꿀 수 있다.
- 반대로 가장 낮은 계층에 있는 코드는 연결된 상위 계층이 많기 때문에 시간이 지나도 변하지 않는 코드로 존재해야 한다.
- 카피-온-라이트는 가장 낮은 계층에 존재
- 직접 구현패턴처럼 함수를 추출해 낮은 계층으로 보내거나, 작은 인터페이스 패턴 처럼 더 높은 계층에 함수를 추가하는 일은 변경 가능성을 고려하여 계층화 작업 하는 것임

<br/>
<br/>

## 아래에 있는 코드는 테스트가 중요하다

- 모든 코드를 테스트하는 것은 현실적으로 어려움 → 패턴을 사용하면 테스트 가능성에 맞춰 코드를 계층화 할 수 있음
- 위쪽에 있는 코드는 자주 바뀌기때문에 테스트도 자주 바뀌지만 아래에 있는 코드는 테스트가 자주 바뀌지 않고 테스트를 할 수록 얻은 것이 더 오래간다.
- 아래에 있는 코드가 재사용 하기 더 좋음

<br/>
<br/>


## 요점 정리

- 추상화 벽 패턴을 사용하면 세부적인 것을 감추기 때문에 더 높은 차원에서 생각할 수 있다
- 작은 인터페이스 패턴을 사용하면 완성된 인터페이스에 가깝게 계층을 만들 수 있다.
- 비즈니스 개념을 표현하는 인터페이스는 잘 만들어야 하고 바뀌지 않아야 한다.
- 편리한 계층 패턴을 이용하면 다른 패턴을 요구사항에 맞게 사용할 수 있다.
- 호출 그래프 구조에서 규칙을 얻을 수 있다. 이 규칙으로 테스트성, 유지보수성, 재사용성을 판단할 수 있다.
